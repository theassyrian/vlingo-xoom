package io.vlingo.xoom.management.endpoints;

import com.google.gson.GsonBuilder;
import io.micronaut.management.endpoint.annotation.Endpoint;
import io.micronaut.management.endpoint.annotation.Read;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.Operation;
import io.swagger.v3.oas.models.PathItem;
import io.swagger.v3.oas.models.Paths;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.media.Content;
import io.swagger.v3.oas.models.media.MediaType;
import io.swagger.v3.oas.models.media.Schema;
import io.swagger.v3.oas.models.parameters.Parameter;
import io.swagger.v3.oas.models.parameters.RequestBody;
import io.swagger.v3.oas.models.responses.ApiResponse;
import io.swagger.v3.oas.models.responses.ApiResponses;
import io.vlingo.xoom.VlingoServer;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Endpoint(id = "openapi", prefix = "custom", defaultEnabled = true, defaultSensitive = false)
public class OpenApiEndpoint {
    private final VlingoServer server;

    public OpenApiEndpoint(VlingoServer server) {
        this.server = server;
    }

    @Read
    @SuppressWarnings("unchecked")
    public Object getSpecification() {

        OpenAPI spec = new OpenAPI();
        Paths paths = new Paths();

        spec.setInfo(Optional.of(new Info()).map(info -> {
            String applicationName = server.getApplicationConfiguration().getName().orElse("application");
            info.setTitle("Vlingo Xoom API: " + applicationName);
            info.setVersion("1.0.0");
            info.setDescription(String.format("An OpenAPI specification for [%s] generated by Vlingo Xoom.",
                    applicationName));
            return info;
        }).get());

        server.getEndpoints().forEach(e -> Stream.of(e.getHandlers()).forEach(r -> {
            PathItem pathItem = new PathItem();
            Operation operation = new Operation();

            String[] params = r.actionSignature.split(",");
            List<Parameter> parameters = Stream.of(params).map(p -> p.split(" "))
                    .filter(p -> p.length == 2)
                    .map(p -> {
                        Parameter parameter = new Parameter();
                        parameter.setName(p[1]);
                        parameter.setIn("path");
                        Schema schema = new Schema();
                        schema.setType(convertTypeToSpecification(p[0]));
                        parameter.setSchema(schema);
                        return parameter;
                    }).collect(Collectors.toList());

            pathItem.setParameters(parameters);

            operation.addTagsItem(e.getName());

            if (r.bodyType != null) {
                RequestBody requestBody = new RequestBody();
                Content content = new Content();
                MediaType mediaType = new MediaType();
                try {
                    Object example = r.bodyType.newInstance();
                    GsonBuilder builder = new GsonBuilder().serializeNulls();
                    Map<String, Object> map = new HashMap<>();
                    map = builder.create()
                            .fromJson(builder.create().toJson(example),
                                    (Class<Map<String, Object>>) map.getClass());
                    mediaType.setExample(map);
                    content.addMediaType(e.getContentTypeResponseHeader().value, mediaType);
                    requestBody.setContent(content);
                    requestBody.setDescription(r.bodyType.getName());
                } catch (InstantiationException | IllegalAccessException ignored) {
                }
                operation.setRequestBody(requestBody);
            }

            operation.setResponses(Optional.of(new ApiResponses()).map(apiResponses -> {
                apiResponses.addApiResponse("default", Optional.of(new ApiResponse()).map(response -> {
                    response.content(Optional.of(new Content()).map(content -> {
                        content.addMediaType(e.getContentTypeResponseHeader().value,
                                Optional.of(new MediaType()).map(mediaType -> {
                                    Schema schema = new Schema();
                                    schema.setType(convertTypeToSpecification(Optional.ofNullable(r.bodyType)
                                            .map(Class::getSimpleName)
                                            .orElse("string")));
                                    mediaType.setSchema(schema);
                                    return mediaType;
                                }).get());
                        return content;
                    }).get());
                    response.setDescription("Default API response inferred from Vlingo Xoom runtime context");
                    return response;
                }).get());
                return apiResponses;
            }).get());

            switch (r.method) {
                case POST:
                    pathItem.setPost(operation);
                    break;
                case GET:
                case CONNECT:
                    pathItem.setGet(operation);
                    break;
                case PUT:
                    pathItem.setPut(operation);
                    break;
                case PATCH:
                    pathItem.setPatch(operation);
                    break;
                case DELETE:
                    pathItem.setDelete(operation);
                    break;
                case HEAD:
                    pathItem.setHead(operation);
                    break;
                case TRACE:
                    pathItem.setTrace(operation);
                    break;
                case OPTIONS:
                    pathItem.setOptions(operation);
                    break;
            }

            paths.addPathItem(r.path, pathItem);
        }));

        spec.setPaths(paths);
        return spec;
    }

    private String convertTypeToSpecification(String javaType) {
        String result;
        switch (javaType) {
            case "long":
                result = "integer";
                break;
            case "double":
            case "float":
                result = "number";
                break;
            case "string":
            case "boolean":
            case "array":
                result = javaType;
                break;
            default:
                result = "object";
        }

        return result;
    }
}
